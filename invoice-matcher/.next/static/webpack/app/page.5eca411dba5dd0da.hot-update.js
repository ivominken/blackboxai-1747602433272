"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/parsers.ts":
/*!****************************!*\
  !*** ./src/lib/parsers.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   amountsAreEqual: function() { return /* binding */ amountsAreEqual; },\n/* harmony export */   extractInvoiceNumbers: function() { return /* binding */ extractInvoiceNumbers; },\n/* harmony export */   parseBankCSV: function() { return /* binding */ parseBankCSV; },\n/* harmony export */   parseDutchAmount: function() { return /* binding */ parseDutchAmount; },\n/* harmony export */   parseInvoiceCSV: function() { return /* binding */ parseInvoiceCSV; },\n/* harmony export */   standardizeDate: function() { return /* binding */ standardizeDate; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"(app-pages-browser)/./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Utility functions for parsing CSV files with specific Dutch formatting\n */ \n/**\n * Convert Dutch formatted amount string to number in cents\n * @param amount Amount string in Dutch format (e.g., \"1.234,56\" or \"-1.234,56\") or standard format (-1234.56)\n * @returns ParsedAmount object with value in cents\n */ function parseDutchAmount(amount) {\n    console.log(\"Parsing Dutch amount:\", amount);\n    // Remove whitespace and handle negative numbers\n    const cleanAmount = amount.trim().replace(/\\s+/g, \"\");\n    console.log(\"After cleaning whitespace:\", cleanAmount);\n    const isNegative = cleanAmount.startsWith(\"-\");\n    console.log(\"Is negative:\", isNegative);\n    // Detect format: if it has a comma, it's Dutch format, otherwise standard decimal\n    const isDutchFormat = cleanAmount.includes(\",\");\n    console.log(\"Is Dutch format:\", isDutchFormat);\n    let standardized;\n    if (isDutchFormat) {\n        // Convert Dutch notation (1.234,56) to standard number\n        standardized = cleanAmount.replace(/\\./g, \"\") // Remove thousands separators\n        .replace(\",\", \".\"); // Convert decimal comma to point\n    } else {\n        // Already in standard decimal format (-1234.56)\n        standardized = cleanAmount;\n    }\n    console.log(\"After standardizing:\", standardized);\n    // Remove any remaining non-numeric chars except decimal point and minus\n    standardized = standardized.replace(/[^0-9.\\-]/g, \"\");\n    console.log(\"After cleaning:\", standardized);\n    // Convert to cents (multiply by 100)\n    const floatValue = parseFloat(standardized);\n    console.log(\"After parsing to float:\", floatValue);\n    const valueInCents = Math.round(floatValue * 100);\n    console.log(\"Final value in cents:\", valueInCents);\n    return {\n        value: valueInCents,\n        original: amount.trim()\n    };\n}\n/**\n * Convert Dutch date format to ISO date string\n * @param date Date string in DD-MM-YYYY format\n * @returns Date string in YYYY-MM-DD format\n */ function standardizeDate(date) {\n    let format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"NL\";\n    if (format === \"NL\") {\n        // Convert DD-MM-YYYY to YYYY-MM-DD\n        const [day, month, year] = date.split(\"-\");\n        return \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n    }\n    // Already in ISO format YYYY-MM-DD\n    return date;\n}\nfunction isRabobankFormat(row) {\n    return \"Munt\" in row && \"BIC\" in row && \"Volgnr\" in row;\n}\n/**\n * Parse bank transactions CSV (ANSI encoded, comma-separated)\n */ async function parseBankCSV(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            var _event_target;\n            if (!((_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result)) {\n                reject(new Error(\"Failed to read file\"));\n                return;\n            }\n            const config = {\n                header: true,\n                delimiter: \",\",\n                newline: \"\\n\",\n                skipEmptyLines: true,\n                quoteChar: '\"',\n                complete: (results)=>{\n                    try {\n                        if (results.errors.length > 0) {\n                            throw new Error(results.errors[0].message);\n                        }\n                        const transactions = results.data.filter((row)=>{\n                            if (isRabobankFormat(row)) {\n                                return row[\"Datum\"] && row[\"Bedrag\"];\n                            } else {\n                                return row[\"Datum\"] && row[\"Bedrag\"];\n                            }\n                        }).map((row)=>{\n                            if (isRabobankFormat(row)) {\n                                return {\n                                    datum: row[\"Datum\"] || \"\",\n                                    bedrag: row[\"Bedrag\"] || \"\",\n                                    omschrijving1: row[\"Omschrijving-1\"] || \"\",\n                                    omschrijving2: row[\"Omschrijving-2\"] || \"\",\n                                    omschrijving3: row[\"Omschrijving-3\"] || \"\",\n                                    transactiereferentie: row[\"Transactiereferentie\"] || row[\"Volgnr\"] || \"\",\n                                    naamTegenpartij: row[\"Naam tegenpartij\"] || \"\",\n                                    iban: row[\"Tegenrekening IBAN/BBAN\"] || row[\"IBAN/BBAN\"] || \"\"\n                                };\n                            } else {\n                                return {\n                                    datum: row[\"Datum\"] || \"\",\n                                    bedrag: row[\"Bedrag\"] || \"\",\n                                    omschrijving1: row[\"Omschrijving-1\"] || \"\",\n                                    omschrijving2: row[\"Omschrijving-2\"] || \"\",\n                                    omschrijving3: row[\"Omschrijving-3\"] || \"\",\n                                    transactiereferentie: row[\"Transactiereferentie\"] || \"\",\n                                    naamTegenpartij: row[\"Naam tegenpartij\"] || \"\",\n                                    iban: row[\"IBAN/BBAN\"] || \"\"\n                                };\n                            }\n                        });\n                        resolve(transactions);\n                    } catch (error) {\n                        reject(new Error(\"Failed to parse bank transactions: \".concat(error.message)));\n                    }\n                }\n            };\n            papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(event.target.result, config);\n        };\n        reader.onerror = ()=>{\n            reject(new Error(\"Failed to read file\"));\n        };\n        reader.readAsText(file, \"windows-1252\");\n    });\n}\n/**\n * Parse invoice CSV (UTF-8 encoded, tab-separated)\n */ async function parseInvoiceCSV(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            var _event_target;\n            if (!((_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result)) {\n                reject(new Error(\"Failed to read file\"));\n                return;\n            }\n            // Pre-process the CSV content to remove leading/trailing whitespace and tabs\n            const cleanedContent = event.target.result.split(\"\\n\").map((line)=>line.trim()).join(\"\\n\");\n            const config = {\n                header: true,\n                delimiter: \"\t\",\n                newline: \"\\n\",\n                skipEmptyLines: true,\n                quoteChar: '\"',\n                transformHeader: (header)=>header.trim(),\n                transform: (value)=>value.trim(),\n                complete: (results)=>{\n                    try {\n                        if (results.errors.length > 0) {\n                            throw new Error(results.errors[0].message);\n                        }\n                        const invoices = results.data.filter((row)=>row[\"Factuurnummer\"] && row[\"Bedrag incl. BTW\"]).map((row)=>{\n                            var _row_Factuurdatum, _row_Factuurnummer, _row_BedraginclBTW, _row_Status, _row_Vergoedbedrag, _row_Debiteur, _row_Debnr;\n                            return {\n                                factuurdatum: ((_row_Factuurdatum = row[\"Factuurdatum\"]) === null || _row_Factuurdatum === void 0 ? void 0 : _row_Factuurdatum.trim()) || \"\",\n                                factuurnummer: ((_row_Factuurnummer = row[\"Factuurnummer\"]) === null || _row_Factuurnummer === void 0 ? void 0 : _row_Factuurnummer.trim()) || \"\",\n                                bedragInclBtw: ((_row_BedraginclBTW = row[\"Bedrag incl. BTW\"]) === null || _row_BedraginclBTW === void 0 ? void 0 : _row_BedraginclBTW.trim()) || \"\",\n                                status: ((_row_Status = row[\"Status\"]) === null || _row_Status === void 0 ? void 0 : _row_Status.trim()) || \"\",\n                                vergoedBedrag: ((_row_Vergoedbedrag = row[\"Vergoed bedrag\"]) === null || _row_Vergoedbedrag === void 0 ? void 0 : _row_Vergoedbedrag.trim()) || \"0,00\",\n                                debiteur: ((_row_Debiteur = row[\"Debiteur\"]) === null || _row_Debiteur === void 0 ? void 0 : _row_Debiteur.trim()) || \"\",\n                                debNr: ((_row_Debnr = row[\"Deb. nr.\"]) === null || _row_Debnr === void 0 ? void 0 : _row_Debnr.trim()) || \"\"\n                            };\n                        });\n                        resolve(invoices);\n                    } catch (error) {\n                        reject(new Error(\"Failed to parse invoices: \".concat(error.message)));\n                    }\n                }\n            };\n            papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(cleanedContent, config);\n        };\n        reader.onerror = ()=>{\n            reject(new Error(\"Failed to read file\"));\n        };\n        reader.readAsText(file, \"UTF-8\");\n    });\n}\n/**\n * Check if amounts are equal (within 1 cent difference due to rounding)\n */ function amountsAreEqual(amount1, amount2) {\n    return Math.abs(amount1.value - amount2.value) <= 1;\n}\n/**\n * Extract possible invoice numbers from bank transaction description\n */ function extractInvoiceNumbers(transaction) {\n    const descriptions = [\n        transaction.omschrijving1,\n        transaction.omschrijving2,\n        transaction.omschrijving3,\n        transaction.transactiereferentie\n    ].filter(Boolean);\n    const invoicePattern = /\\b20[0-9]{8,9}\\b/g; // Matches both formats: 2023120001 and 202400000707\n    return Array.from(new Set(descriptions.flatMap((desc)=>desc.match(invoicePattern) || [])));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQ3hFLE9BQU9wRSxLQUFLcUUsR0FBRyxDQUFDRixRQUFRakUsS0FBSyxHQUFHa0UsUUFBUWxFLEtBQUssS0FBSztBQUN0RDtBQUVBOztDQUVDLEdBQ00sU0FBU29FLHNCQUFzQkMsV0FBNEI7SUFDOUQsTUFBTUMsZUFBZTtRQUNqQkQsWUFBWTdCLGFBQWE7UUFDekI2QixZQUFZNUIsYUFBYTtRQUN6QjRCLFlBQVkzQixhQUFhO1FBQ3pCMkIsWUFBWTFCLG9CQUFvQjtLQUNuQyxDQUFDUCxNQUFNLENBQUNtQztJQUVULE1BQU1DLGlCQUFpQixxQkFBcUIsb0RBQW9EO0lBRWhHLE9BQU9DLE1BQU1DLElBQUksQ0FBQyxJQUFJQyxJQUNsQkwsYUFBYU0sT0FBTyxDQUFDQyxDQUFBQSxPQUNqQkEsS0FBS0MsS0FBSyxDQUFDTixtQkFBbUIsRUFBRTtBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL3BhcnNlcnMudHM/YjRiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBwYXJzaW5nIENTViBmaWxlcyB3aXRoIHNwZWNpZmljIER1dGNoIGZvcm1hdHRpbmdcbiAqL1xuaW1wb3J0IFBhcGEsIHsgUGFyc2VSZXN1bHQsIFBhcnNlQ29uZmlnIH0gZnJvbSAncGFwYXBhcnNlJztcbmltcG9ydCB7IEJhbmtUcmFuc2FjdGlvbiwgSW52b2ljZSwgUGFyc2VkQW1vdW50IH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQ29udmVydCBEdXRjaCBmb3JtYXR0ZWQgYW1vdW50IHN0cmluZyB0byBudW1iZXIgaW4gY2VudHNcbiAqIEBwYXJhbSBhbW91bnQgQW1vdW50IHN0cmluZyBpbiBEdXRjaCBmb3JtYXQgKGUuZy4sIFwiMS4yMzQsNTZcIiBvciBcIi0xLjIzNCw1NlwiKSBvciBzdGFuZGFyZCBmb3JtYXQgKC0xMjM0LjU2KVxuICogQHJldHVybnMgUGFyc2VkQW1vdW50IG9iamVjdCB3aXRoIHZhbHVlIGluIGNlbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUR1dGNoQW1vdW50KGFtb3VudDogc3RyaW5nKTogUGFyc2VkQW1vdW50IHtcbiAgICBjb25zb2xlLmxvZygnUGFyc2luZyBEdXRjaCBhbW91bnQ6JywgYW1vdW50KTtcblxuICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlIGFuZCBoYW5kbGUgbmVnYXRpdmUgbnVtYmVyc1xuICAgIGNvbnN0IGNsZWFuQW1vdW50ID0gYW1vdW50LnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICBjb25zb2xlLmxvZygnQWZ0ZXIgY2xlYW5pbmcgd2hpdGVzcGFjZTonLCBjbGVhbkFtb3VudCk7XG4gICAgY29uc3QgaXNOZWdhdGl2ZSA9IGNsZWFuQW1vdW50LnN0YXJ0c1dpdGgoJy0nKTtcbiAgICBjb25zb2xlLmxvZygnSXMgbmVnYXRpdmU6JywgaXNOZWdhdGl2ZSk7XG5cbiAgICAvLyBEZXRlY3QgZm9ybWF0OiBpZiBpdCBoYXMgYSBjb21tYSwgaXQncyBEdXRjaCBmb3JtYXQsIG90aGVyd2lzZSBzdGFuZGFyZCBkZWNpbWFsXG4gICAgY29uc3QgaXNEdXRjaEZvcm1hdCA9IGNsZWFuQW1vdW50LmluY2x1ZGVzKCcsJyk7XG4gICAgY29uc29sZS5sb2coJ0lzIER1dGNoIGZvcm1hdDonLCBpc0R1dGNoRm9ybWF0KTtcblxuICAgIGxldCBzdGFuZGFyZGl6ZWQ6IHN0cmluZztcbiAgICBpZiAoaXNEdXRjaEZvcm1hdCkge1xuICAgICAgICAvLyBDb252ZXJ0IER1dGNoIG5vdGF0aW9uICgxLjIzNCw1NikgdG8gc3RhbmRhcmQgbnVtYmVyXG4gICAgICAgIHN0YW5kYXJkaXplZCA9IGNsZWFuQW1vdW50XG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuL2csICcnKSAgICAgICAgIC8vIFJlbW92ZSB0aG91c2FuZHMgc2VwYXJhdG9yc1xuICAgICAgICAgICAgLnJlcGxhY2UoJywnLCAnLicpOyAgICAgICAgIC8vIENvbnZlcnQgZGVjaW1hbCBjb21tYSB0byBwb2ludFxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFscmVhZHkgaW4gc3RhbmRhcmQgZGVjaW1hbCBmb3JtYXQgKC0xMjM0LjU2KVxuICAgICAgICBzdGFuZGFyZGl6ZWQgPSBjbGVhbkFtb3VudDtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ0FmdGVyIHN0YW5kYXJkaXppbmc6Jywgc3RhbmRhcmRpemVkKTtcblxuICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vbi1udW1lcmljIGNoYXJzIGV4Y2VwdCBkZWNpbWFsIHBvaW50IGFuZCBtaW51c1xuICAgIHN0YW5kYXJkaXplZCA9IHN0YW5kYXJkaXplZC5yZXBsYWNlKC9bXjAtOS5cXC1dL2csICcnKTtcbiAgICBjb25zb2xlLmxvZygnQWZ0ZXIgY2xlYW5pbmc6Jywgc3RhbmRhcmRpemVkKTtcbiAgICBcbiAgICAvLyBDb252ZXJ0IHRvIGNlbnRzIChtdWx0aXBseSBieSAxMDApXG4gICAgY29uc3QgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQoc3RhbmRhcmRpemVkKTtcbiAgICBjb25zb2xlLmxvZygnQWZ0ZXIgcGFyc2luZyB0byBmbG9hdDonLCBmbG9hdFZhbHVlKTtcbiAgICBjb25zdCB2YWx1ZUluQ2VudHMgPSBNYXRoLnJvdW5kKGZsb2F0VmFsdWUgKiAxMDApO1xuICAgIGNvbnNvbGUubG9nKCdGaW5hbCB2YWx1ZSBpbiBjZW50czonLCB2YWx1ZUluQ2VudHMpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZUluQ2VudHMsXG4gICAgICAgIG9yaWdpbmFsOiBhbW91bnQudHJpbSgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IER1dGNoIGRhdGUgZm9ybWF0IHRvIElTTyBkYXRlIHN0cmluZ1xuICogQHBhcmFtIGRhdGUgRGF0ZSBzdHJpbmcgaW4gREQtTU0tWVlZWSBmb3JtYXRcbiAqIEByZXR1cm5zIERhdGUgc3RyaW5nIGluIFlZWVktTU0tREQgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFuZGFyZGl6ZURhdGUoZGF0ZTogc3RyaW5nLCBmb3JtYXQ6ICdOTCcgfCAnSVNPJyA9ICdOTCcpOiBzdHJpbmcge1xuICAgIGlmIChmb3JtYXQgPT09ICdOTCcpIHtcbiAgICAgICAgLy8gQ29udmVydCBERC1NTS1ZWVlZIHRvIFlZWVktTU0tRERcbiAgICAgICAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gZGF0ZS5zcGxpdCgnLScpO1xuICAgICAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbiAgICB9XG4gICAgLy8gQWxyZWFkeSBpbiBJU08gZm9ybWF0IFlZWVktTU0tRERcbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuaW50ZXJmYWNlIEJhbmtDU1ZSb3cge1xuICAgIC8vIFN1cHBvcnQgYm90aCBzaW1wbGUgYW5kIFJhYm9iYW5rIGZvcm1hdHNcbiAgICAnRGF0dW0nPzogc3RyaW5nO1xuICAgICdCZWRyYWcnPzogc3RyaW5nO1xuICAgICdPbXNjaHJpanZpbmctMSc/OiBzdHJpbmc7XG4gICAgJ09tc2NocmlqdmluZy0yJz86IHN0cmluZztcbiAgICAnT21zY2hyaWp2aW5nLTMnPzogc3RyaW5nO1xuICAgICdUcmFuc2FjdGllcmVmZXJlbnRpZSc/OiBzdHJpbmc7XG4gICAgJ05hYW0gdGVnZW5wYXJ0aWonPzogc3RyaW5nO1xuICAgICdJQkFOL0JCQU4nPzogc3RyaW5nO1xuICAgIC8vIFJhYm9iYW5rIHNwZWNpZmljIGZpZWxkc1xuICAgICdNdW50Jz86IHN0cmluZztcbiAgICAnQklDJz86IHN0cmluZztcbiAgICAnVm9sZ25yJz86IHN0cmluZztcbiAgICAnUmVudGVkYXR1bSc/OiBzdHJpbmc7XG4gICAgJ1NhbGRvIG5hIHRybic/OiBzdHJpbmc7XG4gICAgJ1RlZ2VucmVrZW5pbmcgSUJBTi9CQkFOJz86IHN0cmluZztcbiAgICAnTmFhbSB1aXRlaW5kZWxpamtlIHBhcnRpaic/OiBzdHJpbmc7XG4gICAgJ05hYW0gaW5pdGnDq3JlbmRlIHBhcnRpaic/OiBzdHJpbmc7XG4gICAgJ0JJQyB0ZWdlbnBhcnRpaic/OiBzdHJpbmc7XG4gICAgJ0NvZGUnPzogc3RyaW5nO1xuICAgICdCYXRjaCBJRCc/OiBzdHJpbmc7XG4gICAgJ01hY2h0aWdpbmdza2VubWVyayc/OiBzdHJpbmc7XG4gICAgJ0luY2Fzc2FudCBJRCc/OiBzdHJpbmc7XG4gICAgJ0JldGFsaW5nc2tlbm1lcmsnPzogc3RyaW5nO1xuICAgICdSZWRlbiByZXRvdXInPzogc3RyaW5nO1xuICAgICdPb3JzcHIgYmVkcmFnJz86IHN0cmluZztcbiAgICAnT29yc3ByIG11bnQnPzogc3RyaW5nO1xuICAgICdLb2Vycyc/OiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkOyAgLy8gQWxsb3cgb3RoZXIgY29sdW1uc1xufVxuXG5mdW5jdGlvbiBpc1JhYm9iYW5rRm9ybWF0KHJvdzogQmFua0NTVlJvdyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAnTXVudCcgaW4gcm93ICYmICdCSUMnIGluIHJvdyAmJiAnVm9sZ25yJyBpbiByb3c7XG59XG5cbmludGVyZmFjZSBJbnZvaWNlQ1NWUm93IHtcbiAgICAnRmFjdHV1cmRhdHVtJzogc3RyaW5nO1xuICAgICdGYWN0dXVybnVtbWVyJzogc3RyaW5nO1xuICAgICdCZWRyYWcgaW5jbC4gQlRXJzogc3RyaW5nO1xuICAgICdTdGF0dXMnOiBzdHJpbmc7XG4gICAgJ1ZlcmdvZWQgYmVkcmFnJzogc3RyaW5nO1xuICAgICdEZWJpdGV1cic6IHN0cmluZztcbiAgICAnRGViLiBuci4nOiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nOyAgLy8gQWxsb3cgb3RoZXIgY29sdW1uc1xufVxuXG4vKipcbiAqIFBhcnNlIGJhbmsgdHJhbnNhY3Rpb25zIENTViAoQU5TSSBlbmNvZGVkLCBjb21tYS1zZXBhcmF0ZWQpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUJhbmtDU1YoZmlsZTogRmlsZSk6IFByb21pc2U8QmFua1RyYW5zYWN0aW9uW10+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldD8ucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZmlsZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZzogUGFyc2VDb25maWc8QmFua0NTVlJvdz4gPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlbGltaXRlcjogJywnLFxuICAgICAgICAgICAgICAgIG5ld2xpbmU6ICdcXG4nLFxuICAgICAgICAgICAgICAgIHNraXBFbXB0eUxpbmVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHF1b3RlQ2hhcjogJ1wiJyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogKHJlc3VsdHM6IFBhcnNlUmVzdWx0PEJhbmtDU1ZSb3c+KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHRzLmVycm9yc1swXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zOiBCYW5rVHJhbnNhY3Rpb25bXSA9IHJlc3VsdHMuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmFib2JhbmtGb3JtYXQocm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvd1snRGF0dW0nXSAmJiByb3dbJ0JlZHJhZyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvd1snRGF0dW0nXSAmJiByb3dbJ0JlZHJhZyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JhYm9iYW5rRm9ybWF0KHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0dW06IHJvd1snRGF0dW0nXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWRyYWc6IHJvd1snQmVkcmFnJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb21zY2hyaWp2aW5nMTogcm93WydPbXNjaHJpanZpbmctMSddIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9tc2NocmlqdmluZzI6IHJvd1snT21zY2hyaWp2aW5nLTInXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbXNjaHJpanZpbmczOiByb3dbJ09tc2NocmlqdmluZy0zJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3RpZXJlZmVyZW50aWU6IHJvd1snVHJhbnNhY3RpZXJlZmVyZW50aWUnXSB8fCByb3dbJ1ZvbGduciddIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hYW1UZWdlbnBhcnRpajogcm93WydOYWFtIHRlZ2VucGFydGlqJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWJhbjogcm93WydUZWdlbnJla2VuaW5nIElCQU4vQkJBTiddIHx8IHJvd1snSUJBTi9CQkFOJ10gfHwgJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdHVtOiByb3dbJ0RhdHVtJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVkcmFnOiByb3dbJ0JlZHJhZyddIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9tc2NocmlqdmluZzE6IHJvd1snT21zY2hyaWp2aW5nLTEnXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbXNjaHJpanZpbmcyOiByb3dbJ09tc2NocmlqdmluZy0yJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb21zY2hyaWp2aW5nMzogcm93WydPbXNjaHJpanZpbmctMyddIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aWVyZWZlcmVudGllOiByb3dbJ1RyYW5zYWN0aWVyZWZlcmVudGllJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFhbVRlZ2VucGFydGlqOiByb3dbJ05hYW0gdGVnZW5wYXJ0aWonXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYmFuOiByb3dbJ0lCQU4vQkJBTiddIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgYmFuayB0cmFuc2FjdGlvbnM6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFBhcGEucGFyc2UoZXZlbnQudGFyZ2V0LnJlc3VsdCBhcyBzdHJpbmcsIGNvbmZpZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBmaWxlJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUsICd3aW5kb3dzLTEyNTInKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBpbnZvaWNlIENTViAoVVRGLTggZW5jb2RlZCwgdGFiLXNlcGFyYXRlZClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlSW52b2ljZUNTVihmaWxlOiBGaWxlKTogUHJvbWlzZTxJbnZvaWNlW10+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldD8ucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZmlsZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZS1wcm9jZXNzIHRoZSBDU1YgY29udGVudCB0byByZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGFuZCB0YWJzXG4gICAgICAgICAgICBjb25zdCBjbGVhbmVkQ29udGVudCA9IChldmVudC50YXJnZXQucmVzdWx0IGFzIHN0cmluZylcbiAgICAgICAgICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICAgICAgLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcblxuICAgICAgICAgICAgY29uc3QgY29uZmlnOiBQYXJzZUNvbmZpZzxJbnZvaWNlQ1NWUm93PiA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyOiAnXFx0JyxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiAnXFxuJyxcbiAgICAgICAgICAgICAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdW90ZUNoYXI6ICdcIicsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSGVhZGVyOiAoaGVhZGVyKSA9PiBoZWFkZXIudHJpbSgpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogKHZhbHVlKSA9PiB2YWx1ZS50cmltKCksXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IChyZXN1bHRzOiBQYXJzZVJlc3VsdDxJbnZvaWNlQ1NWUm93PikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0cy5lcnJvcnNbMF0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludm9pY2VzOiBJbnZvaWNlW10gPSByZXN1bHRzLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHJvdyA9PiByb3dbJ0ZhY3R1dXJudW1tZXInXSAmJiByb3dbJ0JlZHJhZyBpbmNsLiBCVFcnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHJvdyA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0dXVyZGF0dW06IHJvd1snRmFjdHV1cmRhdHVtJ10/LnRyaW0oKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdHV1cm51bW1lcjogcm93WydGYWN0dXVybnVtbWVyJ10/LnRyaW0oKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVkcmFnSW5jbEJ0dzogcm93WydCZWRyYWcgaW5jbC4gQlRXJ10/LnRyaW0oKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByb3dbJ1N0YXR1cyddPy50cmltKCkgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcmdvZWRCZWRyYWc6IHJvd1snVmVyZ29lZCBiZWRyYWcnXT8udHJpbSgpIHx8ICcwLDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGViaXRldXI6IHJvd1snRGViaXRldXInXT8udHJpbSgpIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJOcjogcm93WydEZWIuIG5yLiddPy50cmltKCkgfHwgJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGludm9pY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBpbnZvaWNlczogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUGFwYS5wYXJzZShjbGVhbmVkQ29udGVudCwgY29uZmlnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIGZpbGUnKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSwgJ1VURi04Jyk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW1vdW50cyBhcmUgZXF1YWwgKHdpdGhpbiAxIGNlbnQgZGlmZmVyZW5jZSBkdWUgdG8gcm91bmRpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbW91bnRzQXJlRXF1YWwoYW1vdW50MTogUGFyc2VkQW1vdW50LCBhbW91bnQyOiBQYXJzZWRBbW91bnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYW1vdW50MS52YWx1ZSAtIGFtb3VudDIudmFsdWUpIDw9IDE7XG59XG5cbi8qKlxuICogRXh0cmFjdCBwb3NzaWJsZSBpbnZvaWNlIG51bWJlcnMgZnJvbSBiYW5rIHRyYW5zYWN0aW9uIGRlc2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SW52b2ljZU51bWJlcnModHJhbnNhY3Rpb246IEJhbmtUcmFuc2FjdGlvbik6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbnMgPSBbXG4gICAgICAgIHRyYW5zYWN0aW9uLm9tc2NocmlqdmluZzEsXG4gICAgICAgIHRyYW5zYWN0aW9uLm9tc2NocmlqdmluZzIsXG4gICAgICAgIHRyYW5zYWN0aW9uLm9tc2NocmlqdmluZzMsXG4gICAgICAgIHRyYW5zYWN0aW9uLnRyYW5zYWN0aWVyZWZlcmVudGllXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBjb25zdCBpbnZvaWNlUGF0dGVybiA9IC9cXGIyMFswLTldezgsOX1cXGIvZzsgLy8gTWF0Y2hlcyBib3RoIGZvcm1hdHM6IDIwMjMxMjAwMDEgYW5kIDIwMjQwMDAwMDcwN1xuICAgIFxuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoXG4gICAgICAgIGRlc2NyaXB0aW9ucy5mbGF0TWFwKGRlc2MgPT4gXG4gICAgICAgICAgICBkZXNjLm1hdGNoKGludm9pY2VQYXR0ZXJuKSB8fCBbXVxuICAgICAgICApXG4gICAgKSk7XG59XG4iXSwibmFtZXMiOlsiUGFwYSIsInBhcnNlRHV0Y2hBbW91bnQiLCJhbW91bnQiLCJjb25zb2xlIiwibG9nIiwiY2xlYW5BbW91bnQiLCJ0cmltIiwicmVwbGFjZSIsImlzTmVnYXRpdmUiLCJzdGFydHNXaXRoIiwiaXNEdXRjaEZvcm1hdCIsImluY2x1ZGVzIiwic3RhbmRhcmRpemVkIiwiZmxvYXRWYWx1ZSIsInBhcnNlRmxvYXQiLCJ2YWx1ZUluQ2VudHMiLCJNYXRoIiwicm91bmQiLCJ2YWx1ZSIsIm9yaWdpbmFsIiwic3RhbmRhcmRpemVEYXRlIiwiZGF0ZSIsImZvcm1hdCIsImRheSIsIm1vbnRoIiwieWVhciIsInNwbGl0IiwiaXNSYWJvYmFua0Zvcm1hdCIsInJvdyIsInBhcnNlQmFua0NTViIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJldmVudCIsInRhcmdldCIsInJlc3VsdCIsIkVycm9yIiwiY29uZmlnIiwiaGVhZGVyIiwiZGVsaW1pdGVyIiwibmV3bGluZSIsInNraXBFbXB0eUxpbmVzIiwicXVvdGVDaGFyIiwiY29tcGxldGUiLCJyZXN1bHRzIiwiZXJyb3JzIiwibGVuZ3RoIiwibWVzc2FnZSIsInRyYW5zYWN0aW9ucyIsImRhdGEiLCJmaWx0ZXIiLCJtYXAiLCJkYXR1bSIsImJlZHJhZyIsIm9tc2NocmlqdmluZzEiLCJvbXNjaHJpanZpbmcyIiwib21zY2hyaWp2aW5nMyIsInRyYW5zYWN0aWVyZWZlcmVudGllIiwibmFhbVRlZ2VucGFydGlqIiwiaWJhbiIsImVycm9yIiwicGFyc2UiLCJvbmVycm9yIiwicmVhZEFzVGV4dCIsInBhcnNlSW52b2ljZUNTViIsImNsZWFuZWRDb250ZW50IiwibGluZSIsImpvaW4iLCJ0cmFuc2Zvcm1IZWFkZXIiLCJ0cmFuc2Zvcm0iLCJpbnZvaWNlcyIsImZhY3R1dXJkYXR1bSIsImZhY3R1dXJudW1tZXIiLCJiZWRyYWdJbmNsQnR3Iiwic3RhdHVzIiwidmVyZ29lZEJlZHJhZyIsImRlYml0ZXVyIiwiZGViTnIiLCJhbW91bnRzQXJlRXF1YWwiLCJhbW91bnQxIiwiYW1vdW50MiIsImFicyIsImV4dHJhY3RJbnZvaWNlTnVtYmVycyIsInRyYW5zYWN0aW9uIiwiZGVzY3JpcHRpb25zIiwiQm9vbGVhbiIsImludm9pY2VQYXR0ZXJuIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwiZmxhdE1hcCIsImRlc2MiLCJtYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/parsers.ts\n"));

/***/ })

});