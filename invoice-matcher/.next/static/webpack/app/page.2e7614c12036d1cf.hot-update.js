"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/parsers.ts":
/*!****************************!*\
  !*** ./src/lib/parsers.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   amountsAreEqual: function() { return /* binding */ amountsAreEqual; },\n/* harmony export */   extractInvoiceNumbers: function() { return /* binding */ extractInvoiceNumbers; },\n/* harmony export */   parseBankCSV: function() { return /* binding */ parseBankCSV; },\n/* harmony export */   parseDutchAmount: function() { return /* binding */ parseDutchAmount; },\n/* harmony export */   parseInvoiceCSV: function() { return /* binding */ parseInvoiceCSV; },\n/* harmony export */   standardizeDate: function() { return /* binding */ standardizeDate; }\n/* harmony export */ });\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! papaparse */ \"(app-pages-browser)/./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Utility functions for parsing CSV files with specific Dutch formatting\n */ \n/**\n * Convert Dutch formatted amount string to number in cents\n * @param amount Amount string in Dutch format (e.g., \"1.234,56\" or \"-1.234,56\")\n * @returns ParsedAmount object with value in cents\n */ function parseDutchAmount(amount) {\n    console.log(\"Parsing Dutch amount:\", amount);\n    // Remove whitespace and handle negative numbers\n    const cleanAmount = amount.trim().replace(/\\s+/g, \"\");\n    console.log(\"After cleaning whitespace:\", cleanAmount);\n    const isNegative = cleanAmount.startsWith(\"-\");\n    console.log(\"Is negative:\", isNegative);\n    // Convert Dutch notation to standard number\n    const withoutThousands = cleanAmount.replace(/\\./g, \"\"); // Remove thousands separators\n    console.log(\"After removing thousands separators:\", withoutThousands);\n    const withDecimalPoint = withoutThousands.replace(\",\", \".\"); // Convert decimal comma to point\n    console.log(\"After converting decimal separator:\", withDecimalPoint);\n    const standardized = withDecimalPoint.replace(/[^0-9.\\-]/g, \"\"); // Remove any remaining non-numeric chars\n    console.log(\"After removing non-numeric chars:\", standardized);\n    // Convert to cents (multiply by 100)\n    const floatValue = parseFloat(standardized);\n    console.log(\"After parsing to float:\", floatValue);\n    const valueInCents = Math.round(floatValue * 100);\n    console.log(\"Final value in cents:\", valueInCents);\n    return {\n        value: valueInCents,\n        original: amount.trim()\n    };\n}\n/**\n * Convert Dutch date format to ISO date string\n * @param date Date string in DD-MM-YYYY format\n * @returns Date string in YYYY-MM-DD format\n */ function standardizeDate(date) {\n    let format = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"NL\";\n    if (format === \"NL\") {\n        // Convert DD-MM-YYYY to YYYY-MM-DD\n        const [day, month, year] = date.split(\"-\");\n        return \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n    }\n    // Already in ISO format YYYY-MM-DD\n    return date;\n}\nfunction isRabobankFormat(row) {\n    return \"Munt\" in row && \"BIC\" in row && \"Volgnr\" in row;\n}\n/**\n * Parse bank transactions CSV (ANSI encoded, comma-separated)\n */ async function parseBankCSV(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            var _event_target;\n            if (!((_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result)) {\n                reject(new Error(\"Failed to read file\"));\n                return;\n            }\n            const config = {\n                header: true,\n                delimiter: \",\",\n                newline: \"\\n\",\n                skipEmptyLines: true,\n                quoteChar: '\"',\n                complete: (results)=>{\n                    try {\n                        if (results.errors.length > 0) {\n                            throw new Error(results.errors[0].message);\n                        }\n                        const transactions = results.data.filter((row)=>{\n                            if (isRabobankFormat(row)) {\n                                return row[\"Datum\"] && row[\"Bedrag\"];\n                            } else {\n                                return row[\"Datum\"] && row[\"Bedrag\"];\n                            }\n                        }).map((row)=>{\n                            if (isRabobankFormat(row)) {\n                                return {\n                                    datum: row[\"Datum\"] || \"\",\n                                    bedrag: row[\"Bedrag\"] || \"\",\n                                    omschrijving1: row[\"Omschrijving-1\"] || \"\",\n                                    omschrijving2: row[\"Omschrijving-2\"] || \"\",\n                                    omschrijving3: row[\"Omschrijving-3\"] || \"\",\n                                    transactiereferentie: row[\"Transactiereferentie\"] || row[\"Volgnr\"] || \"\",\n                                    naamTegenpartij: row[\"Naam tegenpartij\"] || \"\",\n                                    iban: row[\"Tegenrekening IBAN/BBAN\"] || row[\"IBAN/BBAN\"] || \"\"\n                                };\n                            } else {\n                                return {\n                                    datum: row[\"Datum\"] || \"\",\n                                    bedrag: row[\"Bedrag\"] || \"\",\n                                    omschrijving1: row[\"Omschrijving-1\"] || \"\",\n                                    omschrijving2: row[\"Omschrijving-2\"] || \"\",\n                                    omschrijving3: row[\"Omschrijving-3\"] || \"\",\n                                    transactiereferentie: row[\"Transactiereferentie\"] || \"\",\n                                    naamTegenpartij: row[\"Naam tegenpartij\"] || \"\",\n                                    iban: row[\"IBAN/BBAN\"] || \"\"\n                                };\n                            }\n                        });\n                        resolve(transactions);\n                    } catch (error) {\n                        reject(new Error(\"Failed to parse bank transactions: \".concat(error.message)));\n                    }\n                }\n            };\n            papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(event.target.result, config);\n        };\n        reader.onerror = ()=>{\n            reject(new Error(\"Failed to read file\"));\n        };\n        reader.readAsText(file, \"windows-1252\");\n    });\n}\n/**\n * Parse invoice CSV (UTF-8 encoded, tab-separated)\n */ async function parseInvoiceCSV(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            var _event_target;\n            if (!((_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result)) {\n                reject(new Error(\"Failed to read file\"));\n                return;\n            }\n            // Pre-process the CSV content to remove leading/trailing whitespace and tabs\n            const cleanedContent = event.target.result.split(\"\\n\").map((line)=>line.trim()).join(\"\\n\");\n            const config = {\n                header: true,\n                delimiter: \"\t\",\n                newline: \"\\n\",\n                skipEmptyLines: true,\n                quoteChar: '\"',\n                transformHeader: (header)=>header.trim(),\n                transform: (value)=>value.trim(),\n                complete: (results)=>{\n                    try {\n                        if (results.errors.length > 0) {\n                            throw new Error(results.errors[0].message);\n                        }\n                        const invoices = results.data.filter((row)=>row[\"Factuurnummer\"] && row[\"Bedrag incl. BTW\"]).map((row)=>{\n                            var _row_Factuurdatum, _row_Factuurnummer, _row_BedraginclBTW, _row_Status, _row_Vergoedbedrag, _row_Debiteur, _row_Debnr;\n                            return {\n                                factuurdatum: ((_row_Factuurdatum = row[\"Factuurdatum\"]) === null || _row_Factuurdatum === void 0 ? void 0 : _row_Factuurdatum.trim()) || \"\",\n                                factuurnummer: ((_row_Factuurnummer = row[\"Factuurnummer\"]) === null || _row_Factuurnummer === void 0 ? void 0 : _row_Factuurnummer.trim()) || \"\",\n                                bedragInclBtw: ((_row_BedraginclBTW = row[\"Bedrag incl. BTW\"]) === null || _row_BedraginclBTW === void 0 ? void 0 : _row_BedraginclBTW.trim()) || \"\",\n                                status: ((_row_Status = row[\"Status\"]) === null || _row_Status === void 0 ? void 0 : _row_Status.trim()) || \"\",\n                                vergoedBedrag: ((_row_Vergoedbedrag = row[\"Vergoed bedrag\"]) === null || _row_Vergoedbedrag === void 0 ? void 0 : _row_Vergoedbedrag.trim()) || \"0,00\",\n                                debiteur: ((_row_Debiteur = row[\"Debiteur\"]) === null || _row_Debiteur === void 0 ? void 0 : _row_Debiteur.trim()) || \"\",\n                                debNr: ((_row_Debnr = row[\"Deb. nr.\"]) === null || _row_Debnr === void 0 ? void 0 : _row_Debnr.trim()) || \"\"\n                            };\n                        });\n                        resolve(invoices);\n                    } catch (error) {\n                        reject(new Error(\"Failed to parse invoices: \".concat(error.message)));\n                    }\n                }\n            };\n            papaparse__WEBPACK_IMPORTED_MODULE_0___default().parse(cleanedContent, config);\n        };\n        reader.onerror = ()=>{\n            reject(new Error(\"Failed to read file\"));\n        };\n        reader.readAsText(file, \"UTF-8\");\n    });\n}\n/**\n * Check if amounts are equal (within 1 cent difference due to rounding)\n */ function amountsAreEqual(amount1, amount2) {\n    return Math.abs(amount1.value - amount2.value) <= 1;\n}\n/**\n * Extract possible invoice numbers from bank transaction description\n */ function extractInvoiceNumbers(transaction) {\n    const descriptions = [\n        transaction.omschrijving1,\n        transaction.omschrijving2,\n        transaction.omschrijving3,\n        transaction.transactiereferentie\n    ].filter(Boolean);\n    const invoicePattern = /\\b20[0-9]{8,9}\\b/g; // Matches both formats: 2023120001 and 202400000707\n    return Array.from(new Set(descriptions.flatMap((desc)=>desc.match(invoicePattern) || [])));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcGFyc2Vycy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQzBEO0FBRzNEOzs7O0NBSUMsR0FDTSxTQUFTQyxpQkFBaUJDLE1BQWM7SUFDM0NDLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJGO0lBRXJDLGdEQUFnRDtJQUNoRCxNQUFNRyxjQUFjSCxPQUFPSSxJQUFJLEdBQUdDLE9BQU8sQ0FBQyxRQUFRO0lBQ2xESixRQUFRQyxHQUFHLENBQUMsOEJBQThCQztJQUMxQyxNQUFNRyxhQUFhSCxZQUFZSSxVQUFVLENBQUM7SUFDMUNOLFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0JJO0lBRTVCLDRDQUE0QztJQUM1QyxNQUFNRSxtQkFBbUJMLFlBQVlFLE9BQU8sQ0FBQyxPQUFPLEtBQWEsOEJBQThCO0lBQy9GSixRQUFRQyxHQUFHLENBQUMsd0NBQXdDTTtJQUVwRCxNQUFNQyxtQkFBbUJELGlCQUFpQkgsT0FBTyxDQUFDLEtBQUssTUFBVSxpQ0FBaUM7SUFDbEdKLFFBQVFDLEdBQUcsQ0FBQyx1Q0FBdUNPO0lBRW5ELE1BQU1DLGVBQWVELGlCQUFpQkosT0FBTyxDQUFDLGNBQWMsS0FBSyx5Q0FBeUM7SUFDMUdKLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNRO0lBRWpELHFDQUFxQztJQUNyQyxNQUFNQyxhQUFhQyxXQUFXRjtJQUM5QlQsUUFBUUMsR0FBRyxDQUFDLDJCQUEyQlM7SUFDdkMsTUFBTUUsZUFBZUMsS0FBS0MsS0FBSyxDQUFDSixhQUFhO0lBQzdDVixRQUFRQyxHQUFHLENBQUMseUJBQXlCVztJQUVyQyxPQUFPO1FBQ0hHLE9BQU9IO1FBQ1BJLFVBQVVqQixPQUFPSSxJQUFJO0lBQ3pCO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ00sU0FBU2MsZ0JBQWdCQyxJQUFZO1FBQUVDLFNBQUFBLGlFQUF1QjtJQUNqRSxJQUFJQSxXQUFXLE1BQU07UUFDakIsbUNBQW1DO1FBQ25DLE1BQU0sQ0FB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QyxHQUNNLFNBQVNvRSxzQkFBc0JDLFdBQTRCO0lBQzlELE1BQU1DLGVBQWU7UUFDakJELFlBQVk3QixhQUFhO1FBQ3pCNkIsWUFBWTVCLGFBQWE7UUFDekI0QixZQUFZM0IsYUFBYTtRQUN6QjJCLFlBQVkxQixvQkFBb0I7S0FDbkMsQ0FBQ1AsTUFBTSxDQUFDbUM7SUFFVCxNQUFNQyxpQkFBaUIscUJBQXFCLG9EQUFvRDtJQUVoRyxPQUFPQyxNQUFNQyxJQUFJLENBQUMsSUFBSUMsSUFDbEJMLGFBQWFNLE9BQU8sQ0FBQ0MsQ0FBQUEsT0FDakJBLEtBQUtDLEtBQUssQ0FBQ04sbUJBQW1CLEVBQUU7QUFHNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9wYXJzZXJzLnRzP2I0YjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcGFyc2luZyBDU1YgZmlsZXMgd2l0aCBzcGVjaWZpYyBEdXRjaCBmb3JtYXR0aW5nXG4gKi9cbmltcG9ydCBQYXBhLCB7IFBhcnNlUmVzdWx0LCBQYXJzZUNvbmZpZyB9IGZyb20gJ3BhcGFwYXJzZSc7XG5pbXBvcnQgeyBCYW5rVHJhbnNhY3Rpb24sIEludm9pY2UsIFBhcnNlZEFtb3VudCB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIENvbnZlcnQgRHV0Y2ggZm9ybWF0dGVkIGFtb3VudCBzdHJpbmcgdG8gbnVtYmVyIGluIGNlbnRzXG4gKiBAcGFyYW0gYW1vdW50IEFtb3VudCBzdHJpbmcgaW4gRHV0Y2ggZm9ybWF0IChlLmcuLCBcIjEuMjM0LDU2XCIgb3IgXCItMS4yMzQsNTZcIilcbiAqIEByZXR1cm5zIFBhcnNlZEFtb3VudCBvYmplY3Qgd2l0aCB2YWx1ZSBpbiBjZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEdXRjaEFtb3VudChhbW91bnQ6IHN0cmluZyk6IFBhcnNlZEFtb3VudCB7XG4gICAgY29uc29sZS5sb2coJ1BhcnNpbmcgRHV0Y2ggYW1vdW50OicsIGFtb3VudCk7XG5cbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZSBhbmQgaGFuZGxlIG5lZ2F0aXZlIG51bWJlcnNcbiAgICBjb25zdCBjbGVhbkFtb3VudCA9IGFtb3VudC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgY29uc29sZS5sb2coJ0FmdGVyIGNsZWFuaW5nIHdoaXRlc3BhY2U6JywgY2xlYW5BbW91bnQpO1xuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSBjbGVhbkFtb3VudC5zdGFydHNXaXRoKCctJyk7XG4gICAgY29uc29sZS5sb2coJ0lzIG5lZ2F0aXZlOicsIGlzTmVnYXRpdmUpO1xuICAgIFxuICAgIC8vIENvbnZlcnQgRHV0Y2ggbm90YXRpb24gdG8gc3RhbmRhcmQgbnVtYmVyXG4gICAgY29uc3Qgd2l0aG91dFRob3VzYW5kcyA9IGNsZWFuQW1vdW50LnJlcGxhY2UoL1xcLi9nLCAnJyk7ICAgICAgICAgLy8gUmVtb3ZlIHRob3VzYW5kcyBzZXBhcmF0b3JzXG4gICAgY29uc29sZS5sb2coJ0FmdGVyIHJlbW92aW5nIHRob3VzYW5kcyBzZXBhcmF0b3JzOicsIHdpdGhvdXRUaG91c2FuZHMpO1xuICAgIFxuICAgIGNvbnN0IHdpdGhEZWNpbWFsUG9pbnQgPSB3aXRob3V0VGhvdXNhbmRzLnJlcGxhY2UoJywnLCAnLicpOyAgICAgLy8gQ29udmVydCBkZWNpbWFsIGNvbW1hIHRvIHBvaW50XG4gICAgY29uc29sZS5sb2coJ0FmdGVyIGNvbnZlcnRpbmcgZGVjaW1hbCBzZXBhcmF0b3I6Jywgd2l0aERlY2ltYWxQb2ludCk7XG4gICAgXG4gICAgY29uc3Qgc3RhbmRhcmRpemVkID0gd2l0aERlY2ltYWxQb2ludC5yZXBsYWNlKC9bXjAtOS5cXC1dL2csICcnKTsgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9uLW51bWVyaWMgY2hhcnNcbiAgICBjb25zb2xlLmxvZygnQWZ0ZXIgcmVtb3Zpbmcgbm9uLW51bWVyaWMgY2hhcnM6Jywgc3RhbmRhcmRpemVkKTtcbiAgICBcbiAgICAvLyBDb252ZXJ0IHRvIGNlbnRzIChtdWx0aXBseSBieSAxMDApXG4gICAgY29uc3QgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQoc3RhbmRhcmRpemVkKTtcbiAgICBjb25zb2xlLmxvZygnQWZ0ZXIgcGFyc2luZyB0byBmbG9hdDonLCBmbG9hdFZhbHVlKTtcbiAgICBjb25zdCB2YWx1ZUluQ2VudHMgPSBNYXRoLnJvdW5kKGZsb2F0VmFsdWUgKiAxMDApO1xuICAgIGNvbnNvbGUubG9nKCdGaW5hbCB2YWx1ZSBpbiBjZW50czonLCB2YWx1ZUluQ2VudHMpO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZUluQ2VudHMsXG4gICAgICAgIG9yaWdpbmFsOiBhbW91bnQudHJpbSgpXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IER1dGNoIGRhdGUgZm9ybWF0IHRvIElTTyBkYXRlIHN0cmluZ1xuICogQHBhcmFtIGRhdGUgRGF0ZSBzdHJpbmcgaW4gREQtTU0tWVlZWSBmb3JtYXRcbiAqIEByZXR1cm5zIERhdGUgc3RyaW5nIGluIFlZWVktTU0tREQgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFuZGFyZGl6ZURhdGUoZGF0ZTogc3RyaW5nLCBmb3JtYXQ6ICdOTCcgfCAnSVNPJyA9ICdOTCcpOiBzdHJpbmcge1xuICAgIGlmIChmb3JtYXQgPT09ICdOTCcpIHtcbiAgICAgICAgLy8gQ29udmVydCBERC1NTS1ZWVlZIHRvIFlZWVktTU0tRERcbiAgICAgICAgY29uc3QgW2RheSwgbW9udGgsIHllYXJdID0gZGF0ZS5zcGxpdCgnLScpO1xuICAgICAgICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcbiAgICB9XG4gICAgLy8gQWxyZWFkeSBpbiBJU08gZm9ybWF0IFlZWVktTU0tRERcbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuaW50ZXJmYWNlIEJhbmtDU1ZSb3cge1xuICAgIC8vIFN1cHBvcnQgYm90aCBzaW1wbGUgYW5kIFJhYm9iYW5rIGZvcm1hdHNcbiAgICAnRGF0dW0nPzogc3RyaW5nO1xuICAgICdCZWRyYWcnPzogc3RyaW5nO1xuICAgICdPbXNjaHJpanZpbmctMSc/OiBzdHJpbmc7XG4gICAgJ09tc2NocmlqdmluZy0yJz86IHN0cmluZztcbiAgICAnT21zY2hyaWp2aW5nLTMnPzogc3RyaW5nO1xuICAgICdUcmFuc2FjdGllcmVmZXJlbnRpZSc/OiBzdHJpbmc7XG4gICAgJ05hYW0gdGVnZW5wYXJ0aWonPzogc3RyaW5nO1xuICAgICdJQkFOL0JCQU4nPzogc3RyaW5nO1xuICAgIC8vIFJhYm9iYW5rIHNwZWNpZmljIGZpZWxkc1xuICAgICdNdW50Jz86IHN0cmluZztcbiAgICAnQklDJz86IHN0cmluZztcbiAgICAnVm9sZ25yJz86IHN0cmluZztcbiAgICAnUmVudGVkYXR1bSc/OiBzdHJpbmc7XG4gICAgJ1NhbGRvIG5hIHRybic/OiBzdHJpbmc7XG4gICAgJ1RlZ2VucmVrZW5pbmcgSUJBTi9CQkFOJz86IHN0cmluZztcbiAgICAnTmFhbSB1aXRlaW5kZWxpamtlIHBhcnRpaic/OiBzdHJpbmc7XG4gICAgJ05hYW0gaW5pdGnDq3JlbmRlIHBhcnRpaic/OiBzdHJpbmc7XG4gICAgJ0JJQyB0ZWdlbnBhcnRpaic/OiBzdHJpbmc7XG4gICAgJ0NvZGUnPzogc3RyaW5nO1xuICAgICdCYXRjaCBJRCc/OiBzdHJpbmc7XG4gICAgJ01hY2h0aWdpbmdza2VubWVyayc/OiBzdHJpbmc7XG4gICAgJ0luY2Fzc2FudCBJRCc/OiBzdHJpbmc7XG4gICAgJ0JldGFsaW5nc2tlbm1lcmsnPzogc3RyaW5nO1xuICAgICdSZWRlbiByZXRvdXInPzogc3RyaW5nO1xuICAgICdPb3JzcHIgYmVkcmFnJz86IHN0cmluZztcbiAgICAnT29yc3ByIG11bnQnPzogc3RyaW5nO1xuICAgICdLb2Vycyc/OiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkOyAgLy8gQWxsb3cgb3RoZXIgY29sdW1uc1xufVxuXG5mdW5jdGlvbiBpc1JhYm9iYW5rRm9ybWF0KHJvdzogQmFua0NTVlJvdyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAnTXVudCcgaW4gcm93ICYmICdCSUMnIGluIHJvdyAmJiAnVm9sZ25yJyBpbiByb3c7XG59XG5cbmludGVyZmFjZSBJbnZvaWNlQ1NWUm93IHtcbiAgICAnRmFjdHV1cmRhdHVtJzogc3RyaW5nO1xuICAgICdGYWN0dXVybnVtbWVyJzogc3RyaW5nO1xuICAgICdCZWRyYWcgaW5jbC4gQlRXJzogc3RyaW5nO1xuICAgICdTdGF0dXMnOiBzdHJpbmc7XG4gICAgJ1ZlcmdvZWQgYmVkcmFnJzogc3RyaW5nO1xuICAgICdEZWJpdGV1cic6IHN0cmluZztcbiAgICAnRGViLiBuci4nOiBzdHJpbmc7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nOyAgLy8gQWxsb3cgb3RoZXIgY29sdW1uc1xufVxuXG4vKipcbiAqIFBhcnNlIGJhbmsgdHJhbnNhY3Rpb25zIENTViAoQU5TSSBlbmNvZGVkLCBjb21tYS1zZXBhcmF0ZWQpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUJhbmtDU1YoZmlsZTogRmlsZSk6IFByb21pc2U8QmFua1RyYW5zYWN0aW9uW10+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldD8ucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZmlsZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZzogUGFyc2VDb25maWc8QmFua0NTVlJvdz4gPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRlbGltaXRlcjogJywnLFxuICAgICAgICAgICAgICAgIG5ld2xpbmU6ICdcXG4nLFxuICAgICAgICAgICAgICAgIHNraXBFbXB0eUxpbmVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHF1b3RlQ2hhcjogJ1wiJyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZTogKHJlc3VsdHM6IFBhcnNlUmVzdWx0PEJhbmtDU1ZSb3c+KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHRzLmVycm9yc1swXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zOiBCYW5rVHJhbnNhY3Rpb25bXSA9IHJlc3VsdHMuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocm93ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmFib2JhbmtGb3JtYXQocm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvd1snRGF0dW0nXSAmJiByb3dbJ0JlZHJhZyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvd1snRGF0dW0nXSAmJiByb3dbJ0JlZHJhZyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JhYm9iYW5rRm9ybWF0KHJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0dW06IHJvd1snRGF0dW0nXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWRyYWc6IHJvd1snQmVkcmFnJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb21zY2hyaWp2aW5nMTogcm93WydPbXNjaHJpanZpbmctMSddIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9tc2NocmlqdmluZzI6IHJvd1snT21zY2hyaWp2aW5nLTInXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbXNjaHJpanZpbmczOiByb3dbJ09tc2NocmlqdmluZy0zJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3RpZXJlZmVyZW50aWU6IHJvd1snVHJhbnNhY3RpZXJlZmVyZW50aWUnXSB8fCByb3dbJ1ZvbGduciddIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hYW1UZWdlbnBhcnRpajogcm93WydOYWFtIHRlZ2VucGFydGlqJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWJhbjogcm93WydUZWdlbnJla2VuaW5nIElCQU4vQkJBTiddIHx8IHJvd1snSUJBTi9CQkFOJ10gfHwgJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdHVtOiByb3dbJ0RhdHVtJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVkcmFnOiByb3dbJ0JlZHJhZyddIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9tc2NocmlqdmluZzE6IHJvd1snT21zY2hyaWp2aW5nLTEnXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbXNjaHJpanZpbmcyOiByb3dbJ09tc2NocmlqdmluZy0yJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb21zY2hyaWp2aW5nMzogcm93WydPbXNjaHJpanZpbmctMyddIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aWVyZWZlcmVudGllOiByb3dbJ1RyYW5zYWN0aWVyZWZlcmVudGllJ10gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFhbVRlZ2VucGFydGlqOiByb3dbJ05hYW0gdGVnZW5wYXJ0aWonXSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpYmFuOiByb3dbJ0lCQU4vQkJBTiddIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgYmFuayB0cmFuc2FjdGlvbnM6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFBhcGEucGFyc2UoZXZlbnQudGFyZ2V0LnJlc3VsdCBhcyBzdHJpbmcsIGNvbmZpZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcmVhZCBmaWxlJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUsICd3aW5kb3dzLTEyNTInKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBpbnZvaWNlIENTViAoVVRGLTggZW5jb2RlZCwgdGFiLXNlcGFyYXRlZClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlSW52b2ljZUNTVihmaWxlOiBGaWxlKTogUHJvbWlzZTxJbnZvaWNlW10+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldD8ucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlYWQgZmlsZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZS1wcm9jZXNzIHRoZSBDU1YgY29udGVudCB0byByZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGFuZCB0YWJzXG4gICAgICAgICAgICBjb25zdCBjbGVhbmVkQ29udGVudCA9IChldmVudC50YXJnZXQucmVzdWx0IGFzIHN0cmluZylcbiAgICAgICAgICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgICAgICAgLm1hcChsaW5lID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcblxuICAgICAgICAgICAgY29uc3QgY29uZmlnOiBQYXJzZUNvbmZpZzxJbnZvaWNlQ1NWUm93PiA9IHtcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyOiAnXFx0JyxcbiAgICAgICAgICAgICAgICBuZXdsaW5lOiAnXFxuJyxcbiAgICAgICAgICAgICAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdW90ZUNoYXI6ICdcIicsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSGVhZGVyOiAoaGVhZGVyKSA9PiBoZWFkZXIudHJpbSgpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogKHZhbHVlKSA9PiB2YWx1ZS50cmltKCksXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IChyZXN1bHRzOiBQYXJzZVJlc3VsdDxJbnZvaWNlQ1NWUm93PikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0cy5lcnJvcnNbMF0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGludm9pY2VzOiBJbnZvaWNlW10gPSByZXN1bHRzLmRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHJvdyA9PiByb3dbJ0ZhY3R1dXJudW1tZXInXSAmJiByb3dbJ0JlZHJhZyBpbmNsLiBCVFcnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKHJvdyA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0dXVyZGF0dW06IHJvd1snRmFjdHV1cmRhdHVtJ10/LnRyaW0oKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdHV1cm51bW1lcjogcm93WydGYWN0dXVybnVtbWVyJ10/LnRyaW0oKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVkcmFnSW5jbEJ0dzogcm93WydCZWRyYWcgaW5jbC4gQlRXJ10/LnRyaW0oKSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByb3dbJ1N0YXR1cyddPy50cmltKCkgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcmdvZWRCZWRyYWc6IHJvd1snVmVyZ29lZCBiZWRyYWcnXT8udHJpbSgpIHx8ICcwLDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGViaXRldXI6IHJvd1snRGViaXRldXInXT8udHJpbSgpIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJOcjogcm93WydEZWIuIG5yLiddPy50cmltKCkgfHwgJydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGludm9pY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBpbnZvaWNlczogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUGFwYS5wYXJzZShjbGVhbmVkQ29udGVudCwgY29uZmlnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZWFkIGZpbGUnKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSwgJ1VURi04Jyk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW1vdW50cyBhcmUgZXF1YWwgKHdpdGhpbiAxIGNlbnQgZGlmZmVyZW5jZSBkdWUgdG8gcm91bmRpbmcpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbW91bnRzQXJlRXF1YWwoYW1vdW50MTogUGFyc2VkQW1vdW50LCBhbW91bnQyOiBQYXJzZWRBbW91bnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoYW1vdW50MS52YWx1ZSAtIGFtb3VudDIudmFsdWUpIDw9IDE7XG59XG5cbi8qKlxuICogRXh0cmFjdCBwb3NzaWJsZSBpbnZvaWNlIG51bWJlcnMgZnJvbSBiYW5rIHRyYW5zYWN0aW9uIGRlc2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SW52b2ljZU51bWJlcnModHJhbnNhY3Rpb246IEJhbmtUcmFuc2FjdGlvbik6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbnMgPSBbXG4gICAgICAgIHRyYW5zYWN0aW9uLm9tc2NocmlqdmluZzEsXG4gICAgICAgIHRyYW5zYWN0aW9uLm9tc2NocmlqdmluZzIsXG4gICAgICAgIHRyYW5zYWN0aW9uLm9tc2NocmlqdmluZzMsXG4gICAgICAgIHRyYW5zYWN0aW9uLnRyYW5zYWN0aWVyZWZlcmVudGllXG4gICAgXS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBjb25zdCBpbnZvaWNlUGF0dGVybiA9IC9cXGIyMFswLTldezgsOX1cXGIvZzsgLy8gTWF0Y2hlcyBib3RoIGZvcm1hdHM6IDIwMjMxMjAwMDEgYW5kIDIwMjQwMDAwMDcwN1xuICAgIFxuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoXG4gICAgICAgIGRlc2NyaXB0aW9ucy5mbGF0TWFwKGRlc2MgPT4gXG4gICAgICAgICAgICBkZXNjLm1hdGNoKGludm9pY2VQYXR0ZXJuKSB8fCBbXVxuICAgICAgICApXG4gICAgKSk7XG59XG4iXSwibmFtZXMiOlsiUGFwYSIsInBhcnNlRHV0Y2hBbW91bnQiLCJhbW91bnQiLCJjb25zb2xlIiwibG9nIiwiY2xlYW5BbW91bnQiLCJ0cmltIiwicmVwbGFjZSIsImlzTmVnYXRpdmUiLCJzdGFydHNXaXRoIiwid2l0aG91dFRob3VzYW5kcyIsIndpdGhEZWNpbWFsUG9pbnQiLCJzdGFuZGFyZGl6ZWQiLCJmbG9hdFZhbHVlIiwicGFyc2VGbG9hdCIsInZhbHVlSW5DZW50cyIsIk1hdGgiLCJyb3VuZCIsInZhbHVlIiwib3JpZ2luYWwiLCJzdGFuZGFyZGl6ZURhdGUiLCJkYXRlIiwiZm9ybWF0IiwiZGF5IiwibW9udGgiLCJ5ZWFyIiwic3BsaXQiLCJpc1JhYm9iYW5rRm9ybWF0Iiwicm93IiwicGFyc2VCYW5rQ1NWIiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImV2ZW50IiwidGFyZ2V0IiwicmVzdWx0IiwiRXJyb3IiLCJjb25maWciLCJoZWFkZXIiLCJkZWxpbWl0ZXIiLCJuZXdsaW5lIiwic2tpcEVtcHR5TGluZXMiLCJxdW90ZUNoYXIiLCJjb21wbGV0ZSIsInJlc3VsdHMiLCJlcnJvcnMiLCJsZW5ndGgiLCJtZXNzYWdlIiwidHJhbnNhY3Rpb25zIiwiZGF0YSIsImZpbHRlciIsIm1hcCIsImRhdHVtIiwiYmVkcmFnIiwib21zY2hyaWp2aW5nMSIsIm9tc2NocmlqdmluZzIiLCJvbXNjaHJpanZpbmczIiwidHJhbnNhY3RpZXJlZmVyZW50aWUiLCJuYWFtVGVnZW5wYXJ0aWoiLCJpYmFuIiwiZXJyb3IiLCJwYXJzZSIsIm9uZXJyb3IiLCJyZWFkQXNUZXh0IiwicGFyc2VJbnZvaWNlQ1NWIiwiY2xlYW5lZENvbnRlbnQiLCJsaW5lIiwiam9pbiIsInRyYW5zZm9ybUhlYWRlciIsInRyYW5zZm9ybSIsImludm9pY2VzIiwiZmFjdHV1cmRhdHVtIiwiZmFjdHV1cm51bW1lciIsImJlZHJhZ0luY2xCdHciLCJzdGF0dXMiLCJ2ZXJnb2VkQmVkcmFnIiwiZGViaXRldXIiLCJkZWJOciIsImFtb3VudHNBcmVFcXVhbCIsImFtb3VudDEiLCJhbW91bnQyIiwiYWJzIiwiZXh0cmFjdEludm9pY2VOdW1iZXJzIiwidHJhbnNhY3Rpb24iLCJkZXNjcmlwdGlvbnMiLCJCb29sZWFuIiwiaW52b2ljZVBhdHRlcm4iLCJBcnJheSIsImZyb20iLCJTZXQiLCJmbGF0TWFwIiwiZGVzYyIsIm1hdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/parsers.ts\n"));

/***/ })

});