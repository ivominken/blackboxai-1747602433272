"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/matching.ts":
/*!*****************************!*\
  !*** ./src/lib/matching.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getMatchingStatistics: function() { return /* binding */ getMatchingStatistics; },\n/* harmony export */   matchTransactionsWithInvoices: function() { return /* binding */ matchTransactionsWithInvoices; },\n/* harmony export */   updateMatch: function() { return /* binding */ updateMatch; }\n/* harmony export */ });\n/* harmony import */ var _parsers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parsers */ \"(app-pages-browser)/./src/lib/parsers.ts\");\n\nfunction parseInvoiceDate(dateStr) {\n    // Parse DD-MM-YYYY format\n    const [day, month, year] = dateStr.split(\"-\").map(Number);\n    return new Date(year, month - 1, day);\n}\nfunction parseTransactionDate(dateStr) {\n    // Parse YYYY-MM-DD format\n    const [year, month, day] = dateStr.split(\"-\").map(Number);\n    return new Date(year, month - 1, day);\n}\nfunction cleanDescription(desc) {\n    return desc.toLowerCase().replace(\"factuur \", \"\").trim();\n}\nfunction isFullyPaid(transaction, invoice) {\n    const tAmount = (0,_parsers__WEBPACK_IMPORTED_MODULE_0__.parseDutchAmount)(transaction.bedrag);\n    const iAmount = (0,_parsers__WEBPACK_IMPORTED_MODULE_0__.parseDutchAmount)(invoice.bedragInclBtw);\n    // For CAK payments, consider 75% as fully paid\n    if (transaction.naamTegenpartij.toLowerCase().includes(\"cak\")) {\n        return Math.abs(tAmount.value) >= Math.abs(iAmount.value) * 0.75;\n    }\n    // For other payments, require exact match\n    return Math.abs(tAmount.value) === Math.abs(iAmount.value);\n}\nfunction matchTransactionsWithInvoices(transactions, invoices) {\n    console.log(\"Starting matching process...\");\n    console.log(\"Transactions:\", transactions);\n    console.log(\"Invoices:\", invoices);\n    const results = [];\n    const usedTransactions = new Set();\n    invoices.forEach((invoice)=>{\n        const amount = (0,_parsers__WEBPACK_IMPORTED_MODULE_0__.parseDutchAmount)(invoice.bedragInclBtw);\n        console.log(\"Processing invoice \".concat(invoice.factuurnummer, \" with amount:\"), amount);\n        // Try to find exact match by invoice number in transaction description first\n        const exactMatch = transactions.find((t)=>{\n            if (usedTransactions.has(t.transactiereferentie)) return false;\n            const descriptions = [\n                t.omschrijving1,\n                t.omschrijving2,\n                t.omschrijving3\n            ].filter(Boolean);\n            const cleanInvoiceNumber = invoice.factuurnummer.toLowerCase();\n            const hasInvoiceNumber = descriptions.some((desc)=>{\n                if (!desc) return false;\n                const cleanDesc = cleanDescription(desc);\n                const matches = cleanDesc.includes(cleanInvoiceNumber);\n                console.log(\"Checking invoice number match:\", {\n                    invoiceNumber: cleanInvoiceNumber,\n                    description: cleanDesc,\n                    matches\n                });\n                return matches;\n            });\n            if (!hasInvoiceNumber) return false;\n            // Check if payment amount is sufficient\n            return isFullyPaid(t, invoice);\n        });\n        if (exactMatch) {\n            usedTransactions.add(exactMatch.transactiereferentie);\n            const tAmount = (0,_parsers__WEBPACK_IMPORTED_MODULE_0__.parseDutchAmount)(exactMatch.bedrag);\n            results.push({\n                invoice: {\n                    ...invoice,\n                    status: \"Paid\" // Update status to Paid when invoice number is found and amount matches\n                },\n                bankTransaction: exactMatch,\n                matchType: \"INVOICE_NUMBER\",\n                matchedAmount: tAmount,\n                confidence: 1.0\n            });\n            console.log(\"Found exact match for invoice \".concat(invoice.factuurnummer));\n            return;\n        }\n        // For Definitief invoices, try to find card payment first\n        if (invoice.status === \"Definitief\") {\n            // Find card payment transaction (Rabobank Smart Pay) one day after invoice date\n            const cardPayment = transactions.find((t)=>{\n                if (usedTransactions.has(t.transactiereferentie)) return false;\n                if (t.naamTegenpartij !== \"Rabobank Smart Pay\") return false;\n                const invDate = parseInvoiceDate(invoice.factuurdatum);\n                const transDate = parseTransactionDate(t.datum);\n                // Check if transaction is one day after invoice\n                const dayDiff = (transDate.getTime() - invDate.getTime()) / (1000 * 60 * 60 * 24);\n                if (dayDiff !== 1) return false;\n                return isFullyPaid(t, invoice);\n            });\n            if (cardPayment) {\n                usedTransactions.add(cardPayment.transactiereferentie);\n                results.push({\n                    invoice,\n                    bankTransaction: cardPayment,\n                    matchType: \"CARD_PAYMENT\",\n                    matchedAmount: amount,\n                    confidence: 1.0\n                });\n                console.log(\"Found card payment match for invoice \".concat(invoice.factuurnummer));\n                return;\n            }\n            // If no card payment found, look for regular payment match\n            const matchingTransaction = transactions.find((t)=>{\n                if (usedTransactions.has(t.transactiereferentie)) return false;\n                return isFullyPaid(t, invoice);\n            });\n            if (matchingTransaction) {\n                usedTransactions.add(matchingTransaction.transactiereferentie);\n                console.log(\"Found regular payment match for invoice \".concat(invoice.factuurnummer));\n            }\n            results.push({\n                invoice: {\n                    ...invoice,\n                    status: matchingTransaction ? \"Paid\" : invoice.status\n                },\n                bankTransaction: matchingTransaction,\n                matchType: matchingTransaction ? \"PAID_STATUS\" : \"UNMATCHED\",\n                matchedAmount: amount,\n                confidence: matchingTransaction ? 0.5 : 0\n            });\n            return;\n        }\n        // No match found\n        console.log(\"No match found for invoice \".concat(invoice.factuurnummer));\n        results.push({\n            invoice,\n            bankTransaction: undefined,\n            matchType: \"UNMATCHED\",\n            matchedAmount: amount,\n            confidence: 0\n        });\n    });\n    console.log(\"Matching results:\", results);\n    return results;\n}\nfunction updateMatch(existingMatches, transaction, invoice) {\n    // Remove any existing matches for this invoice\n    const filteredMatches = existingMatches.filter((match)=>match.invoice !== invoice);\n    // Add the new match with updated invoice status\n    filteredMatches.push({\n        bankTransaction: transaction,\n        invoice: {\n            ...invoice,\n            status: transaction ? \"Paid\" : invoice.status // Update status to Paid when manually matched\n        },\n        matchType: transaction ? \"MANUAL\" : \"UNMATCHED\",\n        confidence: transaction ? 1 : 0,\n        matchedAmount: (0,_parsers__WEBPACK_IMPORTED_MODULE_0__.parseDutchAmount)(invoice.bedragInclBtw)\n    });\n    return filteredMatches;\n}\nfunction getMatchingStatistics(matches) {\n    const stats = {\n        totalMatches: matches.length,\n        byType: {\n            PAID_STATUS: 0,\n            INVOICE_NUMBER: 0,\n            CARD_PAYMENT: 0,\n            MANUAL: 0,\n            UNMATCHED: 0\n        },\n        totalAmount: 0,\n        matchedAmount: 0,\n        unmatchedAmount: 0\n    };\n    matches.forEach((match)=>{\n        // Count by type\n        stats.byType[match.matchType]++;\n        // Sum amounts (use absolute values)\n        const amount = Math.abs(match.matchedAmount.value);\n        stats.totalAmount += amount;\n        // Consider both \"Definitief\" and \"Paid\" statuses as matched\n        if (match.invoice.status === \"Definitief\" || match.invoice.status === \"Paid\") {\n            stats.matchedAmount += amount;\n        } else {\n            stats.unmatchedAmount += amount;\n        }\n    });\n    return stats;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFFBQVF5QyxNQUFNLENBQUMsOENBQThDO1FBQ2hHO1FBQ0FFLFdBQVc1QyxjQUFjLFdBQVc7UUFDcEM4QyxZQUFZOUMsY0FBYyxJQUFJO1FBQzlCNkMsZUFBZTlELDBEQUFnQkEsQ0FBQ2tCLFFBQVFJLGFBQWE7SUFDekQ7SUFFQSxPQUFPcUQ7QUFDWDtBQUVPLFNBQVNFLHNCQUFzQnZCLE9BQXNCO0lBQ3hELE1BQU13QixRQUFRO1FBQ1ZDLGNBQWN6QixRQUFRMEIsTUFBTTtRQUM1QkMsUUFBUTtZQUNKQyxhQUFhO1lBQ2JDLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkQyxRQUFRO1lBQ1JDLFdBQVc7UUFDZjtRQUNBQyxhQUFhO1FBQ2J6QixlQUFlO1FBQ2YwQixpQkFBaUI7SUFDckI7SUFFQWxDLFFBQVFsQixPQUFPLENBQUN3QyxDQUFBQTtRQUNaLGdCQUFnQjtRQUNoQkUsTUFBTUcsTUFBTSxDQUFDTCxNQUFNZixTQUFTLENBQUM7UUFFN0Isb0NBQW9DO1FBQ3BDLE1BQU14QixTQUFTWixLQUFLQyxHQUFHLENBQUNrRCxNQUFNZCxhQUFhLENBQUNuQyxLQUFLO1FBQ2pEbUQsTUFBTVMsV0FBVyxJQUFJbEQ7UUFFckIsNERBQTREO1FBQzVELElBQUl1QyxNQUFNMUQsT0FBTyxDQUFDeUMsTUFBTSxLQUFLLGdCQUFnQmlCLE1BQU0xRCxPQUFPLENBQUN5QyxNQUFNLEtBQUssUUFBUTtZQUMxRW1CLE1BQU1oQixhQUFhLElBQUl6QjtRQUMzQixPQUFPO1lBQ0h5QyxNQUFNVSxlQUFlLElBQUluRDtRQUM3QjtJQUNKO0lBRUEsT0FBT3lDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9tYXRjaGluZy50cz8zNWYzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhbmtUcmFuc2FjdGlvbiwgSW52b2ljZSwgUGFyc2VkQW1vdW50IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBwYXJzZUR1dGNoQW1vdW50IH0gZnJvbSAnLi9wYXJzZXJzJztcblxuZXhwb3J0IGludGVyZmFjZSBNYXRjaFJlc3VsdCB7XG4gICAgYmFua1RyYW5zYWN0aW9uPzogQmFua1RyYW5zYWN0aW9uO1xuICAgIGludm9pY2U6IEludm9pY2U7XG4gICAgbWF0Y2hUeXBlOiBNYXRjaFR5cGU7XG4gICAgY29uZmlkZW5jZTogbnVtYmVyO1xuICAgIG1hdGNoZWRBbW91bnQ6IFBhcnNlZEFtb3VudDtcbn1cblxuZXhwb3J0IHR5cGUgTWF0Y2hUeXBlID0gXG4gICAgfCAnUEFJRF9TVEFUVVMnICAgICAgICAvLyBJbnZvaWNlIG1hcmtlZCBhcyBcIkRlZmluaXRpZWZcIiBvciBcIlBhaWRcIlxuICAgIHwgJ0lOVk9JQ0VfTlVNQkVSJyAgICAgLy8gSW52b2ljZSBudW1iZXIgZm91bmQgaW4gYmFuayB0cmFuc2FjdGlvblxuICAgIHwgJ0NBUkRfUEFZTUVOVCcgICAgICAgLy8gQ2FyZCBwYXltZW50IG1hdGNoXG4gICAgfCAnTUFOVUFMJyAgICAgICAgICAgIC8vIE1hbnVhbGx5IG1hdGNoZWRcbiAgICB8ICdVTk1BVENIRUQnOyAgICAgICAgLy8gTm8gbWF0Y2ggZm91bmRcblxuZnVuY3Rpb24gcGFyc2VJbnZvaWNlRGF0ZShkYXRlU3RyOiBzdHJpbmcpOiBEYXRlIHtcbiAgICAvLyBQYXJzZSBERC1NTS1ZWVlZIGZvcm1hdFxuICAgIGNvbnN0IFtkYXksIG1vbnRoLCB5ZWFyXSA9IGRhdGVTdHIuc3BsaXQoJy0nKS5tYXAoTnVtYmVyKTtcbiAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRyYW5zYWN0aW9uRGF0ZShkYXRlU3RyOiBzdHJpbmcpOiBEYXRlIHtcbiAgICAvLyBQYXJzZSBZWVlZLU1NLUREIGZvcm1hdFxuICAgIGNvbnN0IFt5ZWFyLCBtb250aCwgZGF5XSA9IGRhdGVTdHIuc3BsaXQoJy0nKS5tYXAoTnVtYmVyKTtcbiAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpO1xufVxuXG5mdW5jdGlvbiBjbGVhbkRlc2NyaXB0aW9uKGRlc2M6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGRlc2MudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdmYWN0dXVyICcsICcnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVsbHlQYWlkKHRyYW5zYWN0aW9uOiBCYW5rVHJhbnNhY3Rpb24sIGludm9pY2U6IEludm9pY2UpOiBib29sZWFuIHtcbiAgICBjb25zdCB0QW1vdW50ID0gcGFyc2VEdXRjaEFtb3VudCh0cmFuc2FjdGlvbi5iZWRyYWcpO1xuICAgIGNvbnN0IGlBbW91bnQgPSBwYXJzZUR1dGNoQW1vdW50KGludm9pY2UuYmVkcmFnSW5jbEJ0dyk7XG4gICAgXG4gICAgLy8gRm9yIENBSyBwYXltZW50cywgY29uc2lkZXIgNzUlIGFzIGZ1bGx5IHBhaWRcbiAgICBpZiAodHJhbnNhY3Rpb24ubmFhbVRlZ2VucGFydGlqLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NhaycpKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0QW1vdW50LnZhbHVlKSA+PSBNYXRoLmFicyhpQW1vdW50LnZhbHVlKSAqIDAuNzU7XG4gICAgfVxuICAgIFxuICAgIC8vIEZvciBvdGhlciBwYXltZW50cywgcmVxdWlyZSBleGFjdCBtYXRjaFxuICAgIHJldHVybiBNYXRoLmFicyh0QW1vdW50LnZhbHVlKSA9PT0gTWF0aC5hYnMoaUFtb3VudC52YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFRyYW5zYWN0aW9uc1dpdGhJbnZvaWNlcyhcbiAgICB0cmFuc2FjdGlvbnM6IEJhbmtUcmFuc2FjdGlvbltdLFxuICAgIGludm9pY2VzOiBJbnZvaWNlW11cbik6IE1hdGNoUmVzdWx0W10ge1xuICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBtYXRjaGluZyBwcm9jZXNzLi4uJyk7XG4gICAgY29uc29sZS5sb2coJ1RyYW5zYWN0aW9uczonLCB0cmFuc2FjdGlvbnMpO1xuICAgIGNvbnNvbGUubG9nKCdJbnZvaWNlczonLCBpbnZvaWNlcyk7XG5cbiAgICBjb25zdCByZXN1bHRzOiBNYXRjaFJlc3VsdFtdID0gW107XG4gICAgY29uc3QgdXNlZFRyYW5zYWN0aW9ucyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gICAgaW52b2ljZXMuZm9yRWFjaChpbnZvaWNlID0+IHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gcGFyc2VEdXRjaEFtb3VudChpbnZvaWNlLmJlZHJhZ0luY2xCdHcpO1xuICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBpbnZvaWNlICR7aW52b2ljZS5mYWN0dXVybnVtbWVyfSB3aXRoIGFtb3VudDpgLCBhbW91bnQpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgZXhhY3QgbWF0Y2ggYnkgaW52b2ljZSBudW1iZXIgaW4gdHJhbnNhY3Rpb24gZGVzY3JpcHRpb24gZmlyc3RcbiAgICAgICAgY29uc3QgZXhhY3RNYXRjaCA9IHRyYW5zYWN0aW9ucy5maW5kKHQgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZWRUcmFuc2FjdGlvbnMuaGFzKHQudHJhbnNhY3RpZXJlZmVyZW50aWUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICB0Lm9tc2NocmlqdmluZzEsXG4gICAgICAgICAgICAgICAgdC5vbXNjaHJpanZpbmcyLFxuICAgICAgICAgICAgICAgIHQub21zY2hyaWp2aW5nM1xuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuSW52b2ljZU51bWJlciA9IGludm9pY2UuZmFjdHV1cm51bW1lci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgaGFzSW52b2ljZU51bWJlciA9IGRlc2NyaXB0aW9ucy5zb21lKGRlc2MgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZGVzYykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuRGVzYyA9IGNsZWFuRGVzY3JpcHRpb24oZGVzYyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGNsZWFuRGVzYy5pbmNsdWRlcyhjbGVhbkludm9pY2VOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBpbnZvaWNlIG51bWJlciBtYXRjaDonLCB7XG4gICAgICAgICAgICAgICAgICAgIGludm9pY2VOdW1iZXI6IGNsZWFuSW52b2ljZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGNsZWFuRGVzYyxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghaGFzSW52b2ljZU51bWJlcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwYXltZW50IGFtb3VudCBpcyBzdWZmaWNpZW50XG4gICAgICAgICAgICByZXR1cm4gaXNGdWxseVBhaWQodCwgaW52b2ljZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChleGFjdE1hdGNoKSB7XG4gICAgICAgICAgICB1c2VkVHJhbnNhY3Rpb25zLmFkZChleGFjdE1hdGNoLnRyYW5zYWN0aWVyZWZlcmVudGllKTtcbiAgICAgICAgICAgIGNvbnN0IHRBbW91bnQgPSBwYXJzZUR1dGNoQW1vdW50KGV4YWN0TWF0Y2guYmVkcmFnKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW52b2ljZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5pbnZvaWNlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6ICdQYWlkJyAvLyBVcGRhdGUgc3RhdHVzIHRvIFBhaWQgd2hlbiBpbnZvaWNlIG51bWJlciBpcyBmb3VuZCBhbmQgYW1vdW50IG1hdGNoZXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhbmtUcmFuc2FjdGlvbjogZXhhY3RNYXRjaCxcbiAgICAgICAgICAgICAgICBtYXRjaFR5cGU6ICdJTlZPSUNFX05VTUJFUicsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEFtb3VudDogdEFtb3VudCxcbiAgICAgICAgICAgICAgICBjb25maWRlbmNlOiAxLjBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGV4YWN0IG1hdGNoIGZvciBpbnZvaWNlICR7aW52b2ljZS5mYWN0dXVybnVtbWVyfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIERlZmluaXRpZWYgaW52b2ljZXMsIHRyeSB0byBmaW5kIGNhcmQgcGF5bWVudCBmaXJzdFxuICAgICAgICBpZiAoaW52b2ljZS5zdGF0dXMgPT09ICdEZWZpbml0aWVmJykge1xuICAgICAgICAgICAgLy8gRmluZCBjYXJkIHBheW1lbnQgdHJhbnNhY3Rpb24gKFJhYm9iYW5rIFNtYXJ0IFBheSkgb25lIGRheSBhZnRlciBpbnZvaWNlIGRhdGVcbiAgICAgICAgICAgIGNvbnN0IGNhcmRQYXltZW50ID0gdHJhbnNhY3Rpb25zLmZpbmQodCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZWRUcmFuc2FjdGlvbnMuaGFzKHQudHJhbnNhY3RpZXJlZmVyZW50aWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHQubmFhbVRlZ2VucGFydGlqICE9PSAnUmFib2JhbmsgU21hcnQgUGF5JykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGludkRhdGUgPSBwYXJzZUludm9pY2VEYXRlKGludm9pY2UuZmFjdHV1cmRhdHVtKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc0RhdGUgPSBwYXJzZVRyYW5zYWN0aW9uRGF0ZSh0LmRhdHVtKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0cmFuc2FjdGlvbiBpcyBvbmUgZGF5IGFmdGVyIGludm9pY2VcbiAgICAgICAgICAgICAgICBjb25zdCBkYXlEaWZmID0gKHRyYW5zRGF0ZS5nZXRUaW1lKCkgLSBpbnZEYXRlLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCk7XG4gICAgICAgICAgICAgICAgaWYgKGRheURpZmYgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpc0Z1bGx5UGFpZCh0LCBpbnZvaWNlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FyZFBheW1lbnQpIHtcbiAgICAgICAgICAgICAgICB1c2VkVHJhbnNhY3Rpb25zLmFkZChjYXJkUGF5bWVudC50cmFuc2FjdGllcmVmZXJlbnRpZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2ljZSxcbiAgICAgICAgICAgICAgICAgICAgYmFua1RyYW5zYWN0aW9uOiBjYXJkUGF5bWVudCxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hUeXBlOiAnQ0FSRF9QQVlNRU5UJyxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgICAgICAgICBjb25maWRlbmNlOiAxLjBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgY2FyZCBwYXltZW50IG1hdGNoIGZvciBpbnZvaWNlICR7aW52b2ljZS5mYWN0dXVybnVtbWVyfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gY2FyZCBwYXltZW50IGZvdW5kLCBsb29rIGZvciByZWd1bGFyIHBheW1lbnQgbWF0Y2hcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnMuZmluZCh0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodXNlZFRyYW5zYWN0aW9ucy5oYXModC50cmFuc2FjdGllcmVmZXJlbnRpZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdWxseVBhaWQodCwgaW52b2ljZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB1c2VkVHJhbnNhY3Rpb25zLmFkZChtYXRjaGluZ1RyYW5zYWN0aW9uLnRyYW5zYWN0aWVyZWZlcmVudGllKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgcmVndWxhciBwYXltZW50IG1hdGNoIGZvciBpbnZvaWNlICR7aW52b2ljZS5mYWN0dXVybnVtbWVyfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGludm9pY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uaW52b2ljZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBtYXRjaGluZ1RyYW5zYWN0aW9uID8gJ1BhaWQnIDogaW52b2ljZS5zdGF0dXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJhbmtUcmFuc2FjdGlvbjogbWF0Y2hpbmdUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBtYXRjaFR5cGU6IG1hdGNoaW5nVHJhbnNhY3Rpb24gPyAnUEFJRF9TVEFUVVMnIDogJ1VOTUFUQ0hFRCcsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IG1hdGNoaW5nVHJhbnNhY3Rpb24gPyAwLjUgOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIG1hdGNoIGZvdW5kXG4gICAgICAgIGNvbnNvbGUubG9nKGBObyBtYXRjaCBmb3VuZCBmb3IgaW52b2ljZSAke2ludm9pY2UuZmFjdHV1cm51bW1lcn1gKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIGludm9pY2UsXG4gICAgICAgICAgICBiYW5rVHJhbnNhY3Rpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1hdGNoVHlwZTogJ1VOTUFUQ0hFRCcsXG4gICAgICAgICAgICBtYXRjaGVkQW1vdW50OiBhbW91bnQsXG4gICAgICAgICAgICBjb25maWRlbmNlOiAwXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ01hdGNoaW5nIHJlc3VsdHM6JywgcmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNYXRjaChcbiAgICBleGlzdGluZ01hdGNoZXM6IE1hdGNoUmVzdWx0W10sXG4gICAgdHJhbnNhY3Rpb246IEJhbmtUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZCxcbiAgICBpbnZvaWNlOiBJbnZvaWNlXG4pOiBNYXRjaFJlc3VsdFtdIHtcbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIG1hdGNoZXMgZm9yIHRoaXMgaW52b2ljZVxuICAgIGNvbnN0IGZpbHRlcmVkTWF0Y2hlcyA9IGV4aXN0aW5nTWF0Y2hlcy5maWx0ZXIoXG4gICAgICAgIG1hdGNoID0+IG1hdGNoLmludm9pY2UgIT09IGludm9pY2VcbiAgICApO1xuXG4gICAgLy8gQWRkIHRoZSBuZXcgbWF0Y2ggd2l0aCB1cGRhdGVkIGludm9pY2Ugc3RhdHVzXG4gICAgZmlsdGVyZWRNYXRjaGVzLnB1c2goe1xuICAgICAgICBiYW5rVHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLFxuICAgICAgICBpbnZvaWNlOiB7XG4gICAgICAgICAgICAuLi5pbnZvaWNlLFxuICAgICAgICAgICAgc3RhdHVzOiB0cmFuc2FjdGlvbiA/ICdQYWlkJyA6IGludm9pY2Uuc3RhdHVzIC8vIFVwZGF0ZSBzdGF0dXMgdG8gUGFpZCB3aGVuIG1hbnVhbGx5IG1hdGNoZWRcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hUeXBlOiB0cmFuc2FjdGlvbiA/ICdNQU5VQUwnIDogJ1VOTUFUQ0hFRCcsXG4gICAgICAgIGNvbmZpZGVuY2U6IHRyYW5zYWN0aW9uID8gMSA6IDAsXG4gICAgICAgIG1hdGNoZWRBbW91bnQ6IHBhcnNlRHV0Y2hBbW91bnQoaW52b2ljZS5iZWRyYWdJbmNsQnR3KVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZpbHRlcmVkTWF0Y2hlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1hdGNoaW5nU3RhdGlzdGljcyhtYXRjaGVzOiBNYXRjaFJlc3VsdFtdKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICAgIHRvdGFsTWF0Y2hlczogbWF0Y2hlcy5sZW5ndGgsXG4gICAgICAgIGJ5VHlwZToge1xuICAgICAgICAgICAgUEFJRF9TVEFUVVM6IDAsXG4gICAgICAgICAgICBJTlZPSUNFX05VTUJFUjogMCxcbiAgICAgICAgICAgIENBUkRfUEFZTUVOVDogMCxcbiAgICAgICAgICAgIE1BTlVBTDogMCxcbiAgICAgICAgICAgIFVOTUFUQ0hFRDogMFxuICAgICAgICB9LFxuICAgICAgICB0b3RhbEFtb3VudDogMCxcbiAgICAgICAgbWF0Y2hlZEFtb3VudDogMCxcbiAgICAgICAgdW5tYXRjaGVkQW1vdW50OiAwXG4gICAgfTtcblxuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICAgIC8vIENvdW50IGJ5IHR5cGVcbiAgICAgICAgc3RhdHMuYnlUeXBlW21hdGNoLm1hdGNoVHlwZV0rKztcblxuICAgICAgICAvLyBTdW0gYW1vdW50cyAodXNlIGFic29sdXRlIHZhbHVlcylcbiAgICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5hYnMobWF0Y2gubWF0Y2hlZEFtb3VudC52YWx1ZSk7XG4gICAgICAgIHN0YXRzLnRvdGFsQW1vdW50ICs9IGFtb3VudDtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnNpZGVyIGJvdGggXCJEZWZpbml0aWVmXCIgYW5kIFwiUGFpZFwiIHN0YXR1c2VzIGFzIG1hdGNoZWRcbiAgICAgICAgaWYgKG1hdGNoLmludm9pY2Uuc3RhdHVzID09PSAnRGVmaW5pdGllZicgfHwgbWF0Y2guaW52b2ljZS5zdGF0dXMgPT09ICdQYWlkJykge1xuICAgICAgICAgICAgc3RhdHMubWF0Y2hlZEFtb3VudCArPSBhbW91bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0cy51bm1hdGNoZWRBbW91bnQgKz0gYW1vdW50O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RhdHM7XG59XG4iXSwibmFtZXMiOlsicGFyc2VEdXRjaEFtb3VudCIsInBhcnNlSW52b2ljZURhdGUiLCJkYXRlU3RyIiwiZGF5IiwibW9udGgiLCJ5ZWFyIiwic3BsaXQiLCJtYXAiLCJOdW1iZXIiLCJEYXRlIiwicGFyc2VUcmFuc2FjdGlvbkRhdGUiLCJjbGVhbkRlc2NyaXB0aW9uIiwiZGVzYyIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsInRyaW0iLCJpc0Z1bGx5UGFpZCIsInRyYW5zYWN0aW9uIiwiaW52b2ljZSIsInRBbW91bnQiLCJiZWRyYWciLCJpQW1vdW50IiwiYmVkcmFnSW5jbEJ0dyIsIm5hYW1UZWdlbnBhcnRpaiIsImluY2x1ZGVzIiwiTWF0aCIsImFicyIsInZhbHVlIiwibWF0Y2hUcmFuc2FjdGlvbnNXaXRoSW52b2ljZXMiLCJ0cmFuc2FjdGlvbnMiLCJpbnZvaWNlcyIsImNvbnNvbGUiLCJsb2ciLCJyZXN1bHRzIiwidXNlZFRyYW5zYWN0aW9ucyIsIlNldCIsImZvckVhY2giLCJhbW91bnQiLCJmYWN0dXVybnVtbWVyIiwiZXhhY3RNYXRjaCIsImZpbmQiLCJ0IiwiaGFzIiwidHJhbnNhY3RpZXJlZmVyZW50aWUiLCJkZXNjcmlwdGlvbnMiLCJvbXNjaHJpanZpbmcxIiwib21zY2hyaWp2aW5nMiIsIm9tc2NocmlqdmluZzMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY2xlYW5JbnZvaWNlTnVtYmVyIiwiaGFzSW52b2ljZU51bWJlciIsInNvbWUiLCJjbGVhbkRlc2MiLCJtYXRjaGVzIiwiaW52b2ljZU51bWJlciIsImRlc2NyaXB0aW9uIiwiYWRkIiwicHVzaCIsInN0YXR1cyIsImJhbmtUcmFuc2FjdGlvbiIsIm1hdGNoVHlwZSIsIm1hdGNoZWRBbW91bnQiLCJjb25maWRlbmNlIiwiY2FyZFBheW1lbnQiLCJpbnZEYXRlIiwiZmFjdHV1cmRhdHVtIiwidHJhbnNEYXRlIiwiZGF0dW0iLCJkYXlEaWZmIiwiZ2V0VGltZSIsIm1hdGNoaW5nVHJhbnNhY3Rpb24iLCJ1bmRlZmluZWQiLCJ1cGRhdGVNYXRjaCIsImV4aXN0aW5nTWF0Y2hlcyIsImZpbHRlcmVkTWF0Y2hlcyIsIm1hdGNoIiwiZ2V0TWF0Y2hpbmdTdGF0aXN0aWNzIiwic3RhdHMiLCJ0b3RhbE1hdGNoZXMiLCJsZW5ndGgiLCJieVR5cGUiLCJQQUlEX1NUQVRVUyIsIklOVk9JQ0VfTlVNQkVSIiwiQ0FSRF9QQVlNRU5UIiwiTUFOVUFMIiwiVU5NQVRDSEVEIiwidG90YWxBbW91bnQiLCJ1bm1hdGNoZWRBbW91bnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/matching.ts\n"));

/***/ })

});